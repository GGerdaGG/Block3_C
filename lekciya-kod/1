*Этот файл я делала для себя


```
string[,] = new matrix[2, 3];
for (int j = 0; j < matrix.GetLength(0); j++)
{
    for (int i = 0; i < matrix.GetLength(1); i++)
    {
        Console.WriteLine($"matrix[i,j]");
    }
}
```

//Чтобы переименовать переменную сразу везде - выделить ее, нажать F2 и поменять название в окне

```

`=` то, что справа положи в то, что слева
`==` то, что слева равно тому, что справа
`!=` не равно 
`+` плюс 
`-` минус 
`/` прямой слэш - разделить без остатка
`%` значок процента (означает нахождение остатка от деления)
`*` умножение 
> Например 19 % 7 == 5,а не 2,7 потому что в 19 можно поместить две 7, получиться 14 и нам будет не хватать 5 до 19.(19-14=5)
`( )` — классические скобки, которые могут менять приоритет операций 
`&` это побитовый оператор AND (например в n>2 & m>3 проверяться обе стороны )
`&&`это логический оператор AND (например в n>2 && m>3 провериться первое и если не сработет, то второе не будет проверяться )
`|` это побитовый оператор ИЛИ (например в n>2 | m>3 проверяться обе стороны, то есть либо первое, либо второе должны работать )
`||`это логический оператор ИЛИ (например в n>2 || m>3 провериться первое и если не сработет, то второе не будет проверяться )

```
```
int Quarter(int xc, int yc) (с большой буквы и другие названия переменной)
{
Тело метода
    if (если) (xc > 0 && (И) yc > 0) return (вернуть) 1;
    if (xc < 0 && yc > 0) return 2;
    if (xc < 0 && yc < 0) return 3;
    if (xc > 0 && yc < 0) return 4;
    return 0; если не получилось
    if (xc==0 (равно нулю)) ? (тогда) $(если в тексте цифра)"Текст {переменная}" : (иначе) 
    != (не равно)
}
int quarter = Quarter(x, y); (передаем в метод то, что пользователь то что получилось в методе присваеваем в переменную)
```

Здесь всё работает так же, как в математике. Приоритетом являются умножение и деление. Далее, если скобок нет, выполняется сложение и т. д.


ПЕРЕМЕННЫЕ

```
int - челые числа 2
double - вещественные числа, с остатком 2,2
void - не требует return
string - строки, наример буквенные "слово"
bool - метод да или нет if
```

```
int[] = new name[]
int[,] = new name [строки, колонки]






# ЛЕКЦИЯ1

## Пишем код

Сейчас нужно создать некий контейнер (коробку), куда можно положить значения, введённые
пользователем. Соответственно, пишем.
string username = Console.ReadLine();
Console.WriteLine(“Привет, ”);
Console.WriteLine(username):

## Добавляем вывод строки «Введите ваше имя»

Console.WriteLine("Введите Ваше имя ");
string username = Console.ReadLine();
Console.WriteLine("Привет, ");
Console.WriteLine(username);


## Команда Console.Write

Console.Write("Введите Ваше имя ");
string username = Console.ReadLine();
Console.Write("Привет, ");
Console.Write(usrname);

## Новые слова

- WriteLine — вывод в консоль с переходом на новую строку.
- Write — это вывод в консоль без перехода на новую строку.
- ReadLine — позволяет считывать данные из нашего терминала.

## Программа для вычисления частного двух чисел

int numberA = 10;
int numberB = 5;
Console.WriteLine(numberA / numberB);

## Целые и вещественные числа

### Целые через int:
int numberA = 12;
int numberB = 5;
Console.WriteLine(numberA / numberB);

### Вещественные (деляться с остатком) через double:
double numberA = 12;
double numberB = 5;
Console.WriteLine(numberA / numberB);

## Типы данных integer и double
На этом этапе вы должны были запомнить целый тип данных (integer) и вещественный тип данных
(double). Обратите внимание, что типы данных различаются не только по возможности хранить
вещественные числа, но и по объёму памяти, который занимают. Если целые числа позволяют хранить
диапазон от -2 147 483 648 до 2 147 483 647, то тип «double» может хранить числа от ±5,0 × 10-324 до
±1,7 × 10308. Это очень большие значения и, скорее всего, на начальных этапах они вам не понадобятся.

## Тип данных string
Также важно помнить, что есть строки (тип данных «string»). Он может содержать от 0 (это называется
пустой строкой) до большого количества символов, в общем случае до 2 Гб. Это много. Для сравнения,
например, один том «Война и мир» весит около 13 Мб, хотя, возможно, это вес всех книг серии «Война
и мир». То есть строки могут быть очень и очень большими.

## Тип данных bool
Четвёртый тип данных, с которым нужно познакомиться на старте, это логический тип данных. Он
записывается, как bool и позволяет хранить 

## Операторы для арифметических действий в С#
Классические арифметические операции в языке С# определяются следующими операторами:
+ — плюс
- — минус
/ — прямой слэш
* — умножение
% — значок процента (означает нахождение остатка от деления)
( ) — классические скобки, которые могут менять приоритет операций
Здесь всё работает так же, как в математике. Приоритетом являются умножение и деление. Далее, если
скобок нет, выполняется сложение и т. д. 

Команды-помощники программиста на С#. Генератор псевдослучайных чисел

Пример работы оператора

Модифицируем код

Код для персонального приветствия

Пишем код для приложения

Проблемы и ограничения в работе приложения

Программа для решения задачи с гирями


Пишем код

C# vs Java: сходства и различия

Сохраняем проект

Оператор цикла

Приложение с оператором цикла

Пишем код

Запускаем программу

Решаем задачу

Переводим алгоритм в код

Определяем значение оператора цикла

Запускаем приложение

Заключение



Console.Write (“Введите имя пользователя: ”);
string username = Console.ReadLine();
if(username == “Маша”)
{
Сonsole.WriteLine(Ура, это же МАША);
15
}
else
{
Сonsole.Write("Привет, ");
Сonsole.WriteLine(username);
}

---

Console.Write (“Введите имя пользователя: ”);
string username = Console.ReadLine ();
if(username.ToLower() == “маша”) // tolower позволяет не замечать регистр букв - большая или маленькая
{
Сonsole.WriteLine(Ура, это же МАША);
}
else
{
Сonsole.Write("Привет, ");
Сonsole.WriteLine(username);
}

---

Гири:
int a = 1;
int b = 2;
int c = 6;
int d = 8;
int e = 4;
int max = a;
if (a > max ) max = a;
if (b > max ) max = b;
if (c > max ) max = c;
if (d > max ) max = d;
if (e > max ) max = e;
Console.Write(“max = ”);
Console.WriteLine(max);

---
Алгоритм:
1. Определить три точки
2. Выбрать две любых
3. Найти середину
4. Поставить точку
5. Выбрать случайную вершину треугольника
6. Соединить её с полученной на 4 шаге точкой
7. Перейти к шагу 3
8. Шаги 3-7 построить 9, 28, 31 раз 
---

while( УСЛОВИЕ ПРОДОЛЖЕНИЯ)
{
Набор действий
}
Int count = 0;

---

while( count < 100)
{
Набор действий
count = count + 1
} 

---
Треугольник:
Console.Clear.(); // очищает консоль перед программой
Console.Set.CursorPosition(10, 4) // отступ 10 символов и 4 строки
Console.WriteLine(“+”);

Console.Clear.();
Console.Set.CursorPosition(10, 4)
Console.WriteLine(“+”);
int xa = 1, ya = 1,
xb = 1, yb = 30,
xc = 40; yc = 30;
Console.Set.CursorPosition(xa, ya)
Console.WriteLine(“+”);
Console.Set.CursorPosition(xb, yb)
Console.WriteLine(“+”);
Console.Set.CursorPosition(xс, yс)
Console.WriteLine(“+”);

---
int x = xa, y = xb
int count = 0;
while(count < 10)
{
int what = new Random().Next(0, 3);
}

int x = xa, y = xb
int count = 0;
while(count < 10)
{
int what = new Random().Next(0, 3);
if (what == 0)
{
x = (x + xa) / 2;
y = (y + ya) / 2;
}

{
int what = new Random().Next(0, 3);
if (what == 0)
{
x = (x + xa) / 2;
y = (y + ya) / 2;
21
}
if (what == 1)
{
x = (x + xb) / 2;
y = (y + yb) / 2;
}
if (what == 2)
{
x = (x + xс) / 2;
y = (y + yс) / 2;
}

Console.Set.CursorPosition(x, y);
Console.WriteLine(“+”)
count++
}

# ЛЕКЦИЯ2

# Функции 
*Метод для С#
## Функции в программировании
double f(double x)
{
double result = x*x+1; // вычисление необходимого значения
result result // то, что вернёт функция, чтобы в дальнейшем использовать это как 𝑓(2) и кудато сохранить значение, которое посчитает функция.
}

## Поищем максимум из 9 чисел
If(b1>max) max=b1;
If(c1>max) max=c1;
If(a2>max) max=a2;
If(b2>max) max=b2;
If(c2>max) max=c2;
If(a3>max) max=a3;
If(b3>max) max=b3;
If(c3>max) max=c3;

## Функция мах
int Max(int)

int Max(int ard1, int ard2, int ard3)

{
int result = arg1;
if(arg2>result) result=arg2;
if(arg3>result) result=arg3;
return result;
}

int max = Max(
Max(a1, b1, c1)
Max(a2, b2, c2)
Max(a3, b3, c3));


# Массивы
                0 1 2 3 4 5 6 7 8 // индекс
int [] array = {1,2,3,4,5,6,7,8,9};
int [] array = {11,21,31,41,15,61,17,18,19};

int max = Max(
 Max(array[0], array[1], array[2],
Max(array[3], array[4], array[5],
Max(array[6], array[7], array[8]
)
Console.WriteLine(max);

## Устройство массивов внутри компьютера

# Алгоритм
Допустим, у нас есть массив array, в котором n элементов. Найдём элемент, совпадающий с
некоторым значением, который определяет пользователей.
1. Сохраним его в переменную find. Затем установим счётчик в нулевую позицию.
2. Если на текущей позиции элемент совпал с find, операцию можно завершить, потому
что мы нашли позицию.
15
3. Если элемент не совпал с find, увеличиваем значение счётчика index на 1 и переходим
на предыдущий шаг.
4. Сравниваем снова. И если элемент совпал с find, значит, алгоритм закончил работу.
5. Если элемент совпал с find, снова увеличиваем индекс. Смотрим результат.
6. В результате если элемент находится, операция завершается успешно. А если этого
элемента так и нет, надо сообщить об этом.


## Реализация алгоритма
int[] array = {1,12,31,4,15,16,17,18};
int n = array.Length; //.Length определяет длину массива
int find = 4;
Int index = 0;
while (index < n)
{
if(array[index] == find)
{
Console.WriteLine(index);
}
index + +; // или index = index + 1;
}

int[] array = {1,12,31,4,18,15,16,17,18}; //если две одинаковые

int n = array.Length; //.Length определяет длину массива
int find = 4;
Int index = 0;
while (index < n)
{
    if(array[index] == find)
{
Console.WriteLine(index);
break;
}
index + +; // или index = index + 1;
}



# Синтаксис языка
int[] array = new int[10]; // создать новый массив в котором по умолчанию будет 10 элементов, но все они будут нули

void FillArray(int[] collection)
{
int length = collection.Length;
int index = 0;
while (index < length)
{
 //index = index + 1;
 Index++;
}
}

void FillArray(int[] collection)
{
int length = collection.Length;
int index = 0;
while (index < length)
{
 collection[index] = new Random().Next(1, 10);
//index = index + 1;
 Index++;
}
}

void метод ничего не возвращает

FillArray(array);
PrintArray(array);

## Метод IndexOf

Заключение